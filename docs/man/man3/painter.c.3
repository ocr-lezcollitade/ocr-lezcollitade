.TH "src/painter/painter.c" 3 "Tue Nov 22 2022" "OCR-Lezcollitade" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/painter/painter.c
.SH SYNOPSIS
.br
.PP
\fC#include <SDL2/SDL\&.h>\fP
.br
\fC#include <SDL2/SDL_image\&.h>\fP
.br
\fC#include <err\&.h>\fP
.br
\fC#include <malloc\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBdraw\fP (SDL_Renderer *renderer, SDL_Texture *texture)"
.br
.ti -1c
.RI "void \fBsave_texture\fP (const char *file_name, SDL_Renderer *renderer, SDL_Texture *texture)"
.br
.ti -1c
.RI "void \fBupdate_renderer\fP (SDL_Renderer *renderer, int x, int y)"
.br
.ti -1c
.RI "void \fBevent_loop\fP (SDL_Renderer *renderer, SDL_Texture *colored, SDL_Window *\fBwindow\fP)"
.br
.ti -1c
.RI "SDL_Surface * \fBload_image\fP (const char *path)"
.br
.RI "Loads an image into a surface with SDL\&. "
.ti -1c
.RI "Uint32 \fBpixel_to_grayscale\fP (Uint32 pixel_color, SDL_PixelFormat *format)"
.br
.ti -1c
.RI "void \fBsurface_to_grayscale\fP (SDL_Surface *surface)"
.br
.RI "Turns a surface into grayscale\&. "
.ti -1c
.RI "int \fBmax\fP (int a, int b)"
.br
.ti -1c
.RI "int \fBmin\fP (int a, int b)"
.br
.ti -1c
.RI "void \fBupdate_renderer_reverse\fP (SDL_Renderer *renderer, int x, int y)"
.br
.ti -1c
.RI "int \fBmain\fP (int argc, char **argv)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void draw (SDL_Renderer * renderer, SDL_Texture * texture)"

.PP
Definition at line \fB10\fP of file \fBpainter\&.c\fP\&.
.PP
.nf
11 {
12     SDL_RenderCopy(renderer, texture, NULL, NULL);
13     SDL_RenderPresent(renderer);
14 }
.fi
.SS "void event_loop (SDL_Renderer * renderer, SDL_Texture * colored, SDL_Window * window)"

.PP
Definition at line \fB51\fP of file \fBpainter\&.c\fP\&.
.PP
.nf
53 {
54     SDL_Event event;
55     SDL_Texture *t = colored;
56 
57     // int* memory = NULL;
58     // int memsize=0;
59 
60     int clicked = 0;
61 
62     while (1)
63     {
64         SDL_WaitEvent(&event);
65 
66         switch (event\&.type)
67         {
68             case SDL_QUIT:
69                 int w, h;
70                 SDL_GetWindowSize(window, &w, &h);
71                 t = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGB888,
72                     SDL_TEXTUREACCESS_STATIC, w, h);
73                 save_texture("draw\&.png", renderer, t);
74                 // free(memory);
75                 return;
76 
77             case SDL_WINDOWEVENT:
78                 if (event\&.window\&.event == SDL_WINDOWEVENT_RESIZED)
79                 {
80                     draw(renderer, t);
81                 }
82                 break;
83 
84             case SDL_MOUSEBUTTONDOWN:
85                 switch (event\&.button\&.button)
86                 {
87                     case SDL_BUTTON_LEFT:
88                         clicked = 1;
89                         // memory = realloc(memory,memsize+1);
90                         // memory[memsize] = -1;
91                         // memsize++;
92                         break;
93                 }
94                 break;
95 
96             case SDL_MOUSEMOTION:
97                 if (clicked)
98                 {
99                     int x, y;
100                     SDL_GetMouseState(&x, &y);
101                     update_renderer(renderer, x, y);
102                     // memory = realloc(memory,memsize+2);
103                     // memory[memsize] = x;
104                     // memory[memsize+1] = y;
105                     // memsize+=2;
106                 }
107                 break;
108 
109             case SDL_MOUSEBUTTONUP:
110                 switch (event\&.button\&.button)
111                 {
112                     case SDL_BUTTON_LEFT:
113                         clicked = 0;
114                         break;
115                         /*case SDL_BUTTON_RIGHT:
116                            if(memsize>1){
117 
118                                int delta = 1;
119                                int i = memsize-2;
120                                while(memory[i] != -1){
121                                    update_renderer_reverse(renderer,memory[i-1],memory[i]);
122                                    i-=2;
123                                    delta+=2;
124                                }
125                                memory=realloc(memory,memsize-delta);
126                                memsize-=delta;
127                            }
128                            break;*/
129                 }
130                 break;
131         }
132     }
133 }
.fi
.SS "SDL_Surface * load_image (const char * path)"

.PP
Loads an image into a surface with SDL\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path of the image 
.RE
.PP
\fBReturns\fP
.RS 4
The surface corresponding to the image 
.RE
.PP

.PP
Definition at line \fB139\fP of file \fBpainter\&.c\fP\&.
.PP
.nf
140 {
141     SDL_Surface *temp = IMG_Load(path);
142     if (temp == NULL)
143         errx(EXIT_FAILURE, "%s", SDL_GetError());
144     SDL_Surface *surface
145         = SDL_ConvertSurfaceFormat(temp, SDL_PIXELFORMAT_RGB888, 0);
146     if (surface == NULL)
147         errx(EXIT_FAILURE, "%s", SDL_GetError());
148     SDL_FreeSurface(temp);
149     return surface;
150 }
.fi
.SS "int main (int argc, char ** argv)"

.PP
Definition at line \fB200\fP of file \fBpainter\&.c\fP\&.
.PP
.nf
201 {
202     // Checks the number of arguments\&.
203     if (argc != 2)
204         errx(EXIT_FAILURE, "Usage: image-file");
205 
206     // - Initialize the SDL\&.
207 
208     if (SDL_Init(SDL_INIT_VIDEO) != 0)
209         errx(EXIT_FAILURE, "%s", SDL_GetError());
210 
211     // - Create a window\&.
212 
213     SDL_Window *window = SDL_CreateWindow("Image Grayscale", 0, 0, 600, 800,
214         SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);
215     if (window == NULL)
216         errx(EXIT_FAILURE, "%s", SDL_GetError());
217 
218     // - Create a renderer\&.
219 
220     SDL_Renderer *renderer
221         = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
222     if (renderer == NULL)
223         errx(EXIT_FAILURE, "%s", SDL_GetError());
224 
225     // - Create a surface from the colored image\&.
226 
227     SDL_Surface *surface = load_image(argv[1]);
228 
229     // - Resize the window according to the size of the image\&.
230 
231     int w = surface->w;
232     int h = surface->h;
233 
234     SDL_SetWindowSize(window, w, h);
235 
236     // - Create a texture from the colored surface\&.
237 
238     SDL_Texture *colored = SDL_CreateTextureFromSurface(renderer, surface);
239 
240     // - Convert the surface into grayscale\&.
241 
242     // - surface_to_grayscale(surface);
243 
244     // - Create a new texture from the grayscale surface\&.
245 
246     // - SDL_Texture* grayscale =
247     // SDL_CreateTextureFromSurface(renderer,surface);
248 
249     // - Free the surface\&.
250 
251     // - SDL_FreeSurface(surface);
252 
253     // - Dispatch the events\&.
254 
255     event_loop(renderer, colored, window);
256 
257     // - Destroy the objects\&.
258 
259     SDL_FreeSurface(surface);
260     SDL_DestroyTexture(colored);
261     // SDL_DestroyTexture(grayscale);
262     SDL_DestroyRenderer(renderer);
263     SDL_DestroyWindow(window);
264     SDL_Quit();
265 
266     return EXIT_SUCCESS;
267 }
.fi
.SS "int max (int a, int b)"

.PP
Definition at line \fB176\fP of file \fBpainter\&.c\fP\&.
.PP
.nf
177 {
178     return a > b ? a : b;
179 }
.fi
.SS "int min (int a, int b)"

.PP
Definition at line \fB181\fP of file \fBpainter\&.c\fP\&.
.PP
.nf
182 {
183     return a < b ? a : b;
184 }
.fi
.SS "Uint32 pixel_to_grayscale (Uint32 pixel_color, SDL_PixelFormat * format)"

.PP
Definition at line \fB156\fP of file \fBpainter\&.c\fP\&.
.PP
.nf
157 {
158     Uint8 r, g, b;
159     SDL_GetRGB(pixel_color, format, &r, &g, &b);
160     Uint8 average = 0\&.3 * r + 0\&.59 * g + 0\&.11 * b;
161     Uint32 color = SDL_MapRGB(format, average, average, average);
162     return color;
163 }
.fi
.SS "void save_texture (const char * file_name, SDL_Renderer * renderer, SDL_Texture * texture)"

.PP
Definition at line \fB16\fP of file \fBpainter\&.c\fP\&.
.PP
.nf
18 {
19     SDL_Texture *target = SDL_GetRenderTarget(renderer);
20     SDL_SetRenderTarget(renderer, texture);
21     int width, height;
22     SDL_QueryTexture(texture, NULL, NULL, &width, &height);
23     SDL_Surface *surface
24         = SDL_CreateRGBSurface(0, width, height, 32, 0, 0, 0, 0);
25     SDL_RenderReadPixels(renderer, NULL, surface->format->format,
26         surface->pixels, surface->pitch);
27     IMG_SavePNG(surface, file_name);
28     SDL_FreeSurface(surface);
29     SDL_SetRenderTarget(renderer, target);
30 }
.fi
.SS "void surface_to_grayscale (SDL_Surface * surface)"

.PP
Turns a surface into grayscale\&. 
.PP
\fBParameters\fP
.RS 4
\fIsurface\fP The surface to turn into grayscale 
.RE
.PP

.PP
Definition at line \fB165\fP of file \fBpainter\&.c\fP\&.
.PP
.nf
166 {
167     Uint32 *pixels = surface->pixels;
168     int len = surface->w * surface->h;
169     SDL_PixelFormat *format = surface->format;
170     SDL_LockSurface(surface);
171     for (int i = 0; i < len; i++)
172         pixels[i] = pixel_to_grayscale(pixels[i], format);
173     SDL_UnlockSurface(surface);
174 }
.fi
.SS "void update_renderer (SDL_Renderer * renderer, int x, int y)"

.PP
Definition at line \fB32\fP of file \fBpainter\&.c\fP\&.
.PP
.nf
33 {
34 
35     SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
36     for (int i = -2; i < 3; i++)
37     {
38         for (int j = -2; j < 3; j++)
39         {
40             SDL_RenderDrawPoint(renderer, x + i, y + j);
41         }
42     }
43     SDL_RenderPresent(renderer);
44 }
.fi
.SS "void update_renderer_reverse (SDL_Renderer * renderer, int x, int y)"

.PP
Definition at line \fB186\fP of file \fBpainter\&.c\fP\&.
.PP
.nf
187 {
188 
189     SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
190     for (int i = -2; i < 3; i++)
191     {
192         for (int j = -2; j < 3; j++)
193         {
194             SDL_RenderDrawPoint(renderer, x + i, y + j);
195         }
196     }
197     SDL_RenderPresent(renderer);
198 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for OCR-Lezcollitade from the source code\&.
