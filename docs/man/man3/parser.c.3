.TH "src/cli/parser.c" 3 "Tue Nov 22 2022" "OCR-Lezcollitade" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/cli/parser.c
.SH SYNOPSIS
.br
.PP
\fC#include <err\&.h>\fP
.br
\fC#include <malloc\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include 'parser\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBUNUSED\fP(x)   (void)(x)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBparams_t\fP \fBparse_train_params\fP (int argc, char **argv)"
.br
.RI "Parses the train parameters\&. "
.ti -1c
.RI "\fBparams_t\fP \fBparse_test_params\fP (int argc, char **argv)"
.br
.RI "Parses the test parameters\&. "
.ti -1c
.RI "\fBparams_t\fP \fBparse_convert_params\fP (int argc, char **argv)"
.br
.RI "Parses the convert params\&. "
.ti -1c
.RI "\fBparams_t\fP \fBparse_params\fP (int argc, char **argv, char *mode)"
.br
.RI "Parses all the params\&. "
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define UNUSED(x)   (void)(x)"

.PP
Definition at line \fB6\fP of file \fBparser\&.c\fP\&.
.SH "Function Documentation"
.PP 
.SS "\fBparams_t\fP parse_convert_params (int argc, char ** argv)"

.PP
Parses the convert params\&. 
.PP
\fBParameters\fP
.RS 4
\fIargc\fP The argument count\&. 
.br
\fIargv\fP The array of parameters\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The params hash table\&. 
.RE
.PP

.PP
Definition at line \fB163\fP of file \fBparser\&.c\fP\&.
.PP
.nf
164 {
165     params_t params = _parse_convert_params(argc, argv);
166     // TODO : check parameters validity
167     return params;
168 }
.fi
.SS "\fBparams_t\fP parse_params (int argc, char ** argv, char * mode)"

.PP
Parses all the params\&. 
.PP
\fBParameters\fP
.RS 4
\fIargc\fP The number of strings in the argv array\&. 
.br
\fIargv\fP The array of param strings\&. 
.br
\fImode\fP The mode: either TRAIN_MODE or RUN_MODE\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The hash table of params\&. 
.RE
.PP

.PP
Definition at line \fB170\fP of file \fBparser\&.c\fP\&.
.PP
.nf
171 {
172     if (argc < 2)
173     {
174         return NULL;
175     }
176 
177     params_t res = NULL;
178     char *subcommand = argv[1];
179     if (strcmp(subcommand, "train") == 0)
180     {
181         *mode = TRAIN_MODE;
182         res = parse_train_params(argc - 2, argv + 2);
183     }
184     else if (strcmp(subcommand, "test") == 0)
185     {
186         *mode = TEST_MODE;
187         res = parse_test_params(argc - 2, argv + 2);
188     }
189     else if (strcmp(subcommand, "convert") == 0)
190     {
191         *mode = CONVERT_MODE;
192         res = parse_convert_params(argc - 2, argv + 2);
193     }
194     return res;
195 }
.fi
.SS "\fBparams_t\fP parse_test_params (int argc, char ** argv)"

.PP
Parses the test parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fIargc\fP The number of arguments in the array\&. 
.br
\fIargv\fP The array of parameters\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The parameters hash table\&. 
.RE
.PP

.PP
Definition at line \fB155\fP of file \fBparser\&.c\fP\&.
.PP
.nf
156 {
157 
158     params_t params = _parse_params(argc, argv);
159     // TODO : check parameters validity
160     return params;
161 }
.fi
.SS "\fBparams_t\fP parse_train_params (int argc, char ** argv)"

.PP
Parses the train parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fIargc\fP The number of strings in the argv array\&. 
.br
\fIargv\fP The list of strings\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The hash table of params\&. 
.RE
.PP

.PP
Definition at line \fB148\fP of file \fBparser\&.c\fP\&.
.PP
.nf
149 {
150     params_t params = _parse_params(argc, argv);
151     // TODO : check parameters validity
152     return params;
153 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for OCR-Lezcollitade from the source code\&.
