.TH "src/utils/matrices/matrix.c" 3 "Sun Oct 30 2022" "OCR-Lezcollitade" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/utils/matrices/matrix.c
.SH SYNOPSIS
.br
.PP
\fC#include <err\&.h>\fP
.br
\fC#include <malloc\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include 'matrix\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBmat_el_at\fP (\fBmatrix_t\fP *mat, size_t i, size_t j)"
.br
.RI "gets the elements at position i, j "
.ti -1c
.RI "void \fBmat_set_el\fP (\fBmatrix_t\fP *mat, size_t i, size_t j, double value)"
.br
.ti -1c
.RI "\fBmatrix_t\fP * \fBmatrix_create\fP (size_t rows, size_t columns, int fill)"
.br
.ti -1c
.RI "\fBmatrix_t\fP * \fBmat_create_fill\fP (size_t rows, size_t columns, double *elements)"
.br
.RI "Creates a matrix and fills it\&. "
.ti -1c
.RI "void \fBmatrix_free\fP (\fBmatrix_t\fP *mat)"
.br
.RI "frees the matrix "
.ti -1c
.RI "\fBmatrix_t\fP * \fBmat_product\fP (\fBmatrix_t\fP *A, \fBmatrix_t\fP *B)"
.br
.RI "Performs the dot product on 2 \fBmatrix_t\fP structures\&. "
.ti -1c
.RI "\fBmatrix_t\fP * \fBmat_add\fP (\fBmatrix_t\fP *A, \fBmatrix_t\fP *B)"
.br
.RI "Performs the addition of 2 matrices\&. "
.ti -1c
.RI "\fBmatrix_t\fP * \fBmat_transform\fP (\fBmatrix_t\fP *A, \fBmat_transform_t\fP transform, int inplace)"
.br
.RI "Applies the transform to each of the matrix_elements\&. "
.ti -1c
.RI "\fBmatrix_t\fP * \fBmat_scalar_multiply\fP (\fBmatrix_t\fP *A, double scalar, int inplace)"
.br
.RI "Multiplies the matrix by a given scalar\&. "
.ti -1c
.RI "\fBmatrix_t\fP * \fBmat_transpose\fP (\fBmatrix_t\fP *A)"
.br
.RI "Transposes the given matrix\&. "
.ti -1c
.RI "\fBmatrix_t\fP * \fBmat_identity\fP (size_t size)"
.br
.RI "Creates an Identity matrix for given size\&. "
.ti -1c
.RI "int \fBmat_equal\fP (\fBmatrix_t\fP *A, \fBmatrix_t\fP *B)"
.br
.RI "Checks if to matrices are equal\&. "
.ti -1c
.RI "void \fBmat_fill\fP (\fBmatrix_t\fP *mat, double *elements)"
.br
.RI "Fills the matrix with the given elements\&. "
.ti -1c
.RI "void \fBmat_print\fP (\fBmatrix_t\fP *mat)"
.br
.RI "Prints the matrix\&. "
.ti -1c
.RI "\fBmatrix_t\fP * \fBmat_copy\fP (\fBmatrix_t\fP *origin)"
.br
.RI "Copies the matrix\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBmatrix_t\fP * mat_add (\fBmatrix_t\fP * A, \fBmatrix_t\fP * B)"

.PP
Performs the addition of 2 matrices\&. 
.PP
\fBParameters\fP
.RS 4
\fIA\fP The first matrix to be added\&. 
.br
\fIB\fP The second matrix to be added\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The result of the addition, NULL if not possible\&. 
.RE
.PP

.PP
Definition at line \fB74\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
75 {
76     if (A->columns != B->columns || A->rows != B->rows)
77         return NULL;
78 
79     matrix_t *res = matrix_create(A->rows, A->columns, 0);
80     if (res == NULL)
81         return NULL;
82 
83     for (size_t i = 0; i < res->rows; i++)
84         for (size_t j = 0; j < res->columns; j++)
85             mat_set_el(res, i, j, mat_el_at(A, i, j) + mat_el_at(B, i, j));
86 
87     return res;
88 }
.fi
.SS "\fBmatrix_t\fP * mat_copy (\fBmatrix_t\fP * origin)"

.PP
Copies the matrix\&. 
.PP
\fBParameters\fP
.RS 4
\fIorigin\fP The origin matrix\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A copy of the matrix\&. 
.RE
.PP

.PP
Definition at line \fB193\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
194 {
195     matrix_t *result = matrix_create(origin->rows, origin->columns, 0);
196     if (result == NULL)
197         return NULL;
198     for (size_t i = 0; i < origin->rows; i++)
199     {
200         for (size_t j = 0; j < origin->columns; j++)
201         {
202             mat_set_el(result, i, j, mat_el_at(origin, i, j));
203         }
204     }
205 
206     return result;
207 }
.fi
.SS "\fBmatrix_t\fP * mat_create_fill (size_t rows, size_t columns, double * elements)"

.PP
Creates a matrix and fills it\&. 
.PP
\fBParameters\fP
.RS 4
\fIrows\fP The number of rows\&. 
.br
\fIcolumns\fP The number of columns\&. 
.br
\fIelements\fP The values to fill in\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The created matrix\&. 
.RE
.PP

.PP
Definition at line \fB38\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
39 {
40     matrix_t *res = matrix_create(rows, columns, 0);
41     mat_fill(res, elements);
42     return res;
43 }
.fi
.SS "double mat_el_at (\fBmatrix_t\fP * mat, size_t i, size_t j)"

.PP
gets the elements at position i, j 
.PP
\fBParameters\fP
.RS 4
\fImat\fP The \fBmatrix_t\fP to get the element from\&. 
.br
\fIi\fP The index of the row\&. 
.br
\fIj\fP The index of the column\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The value of the element at i, j\&. 
.RE
.PP

.PP
Definition at line \fB6\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
7 {
8     size_t index = i * mat->columns + j;
9     return mat->_elements[index];
10 }
.fi
.SS "int mat_equal (\fBmatrix_t\fP * A, \fBmatrix_t\fP * B)"

.PP
Checks if to matrices are equal\&. 
.PP
\fBParameters\fP
.RS 4
\fIA\fP The first member of the equality\&. 
.br
\fIB\fP The second member of the equality\&. 
.RE
.PP
\fBReturns\fP
.RS 4
1 if the matrices are equal, 0 otherwise\&. 
.RE
.PP

.PP
Definition at line \fB150\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
151 {
152     if (A->rows != B->rows || A->columns != B->columns)
153         return 0;
154 
155     for (size_t i = 0; i < A->rows; i++)
156     {
157         for (size_t j = 0; j < A->columns; j++)
158         {
159             if (mat_el_at(A, i, j) != mat_el_at(B, i, j))
160             {
161                 return 0;
162             }
163         }
164     }
165 
166     return 1;
167 }
.fi
.SS "void mat_fill (\fBmatrix_t\fP * mat, double * elements)"

.PP
Fills the matrix with the given elements\&. 
.PP
\fBParameters\fP
.RS 4
\fImat\fP The matrix to be filled\&. 
.br
\fIelements\fP The array to fill the matrix with\&. It is assumed to have the correct dimensions (rows * columns)\&. 
.RE
.PP

.PP
Definition at line \fB169\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
170 {
171 
172     for (size_t i = 0; i < mat->rows; i++)
173     {
174         for (size_t j = 0; j < mat->columns; j++)
175         {
176             mat_set_el(mat, i, j, elements[i * mat->columns + j]);
177         }
178     }
179 }
.fi
.SS "\fBmatrix_t\fP * mat_identity (size_t size)"

.PP
Creates an Identity matrix for given size\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The number of rows/cols of the matrix\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The Identity matrix\&. 
.RE
.PP

.PP
Definition at line \fB142\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
143 {
144     matrix_t *res = matrix_create(size, size, 1);
145     while (size--)
146         mat_set_el(res, size, size, 1);
147     return res;
148 }
.fi
.SS "void mat_print (\fBmatrix_t\fP * mat)"

.PP
Prints the matrix\&. 
.PP
\fBParameters\fP
.RS 4
\fImat\fP The matrix to print\&. 
.RE
.PP

.PP
Definition at line \fB181\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
182 {
183     for (size_t i = 0; i < mat->rows; i++)
184     {
185         for (size_t j = 0; j < mat->columns; j++)
186         {
187             printf("|%3\&.3f", mat_el_at(mat, i, j));
188         }
189         printf("|\n");
190     }
191 }
.fi
.SS "\fBmatrix_t\fP * mat_product (\fBmatrix_t\fP * A, \fBmatrix_t\fP * B)"

.PP
Performs the dot product on 2 \fBmatrix_t\fP structures\&. 
.PP
\fBParameters\fP
.RS 4
\fIA\fP The first matrix to be multiplied\&. 
.br
\fIB\fP The second matrix to be multiplied\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The resutl of the product, NULL if not possible\&. 
.RE
.PP

.PP
Definition at line \fB51\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
52 {
53     if (A->columns != B->rows)
54         return NULL;
55 
56     matrix_t *res = matrix_create(A->rows, B->columns, 0);
57     if (res == NULL)
58         return NULL;
59 
60     for (size_t i = 0; i < res->rows; i++)
61     {
62         for (size_t j = 0; j < res->columns; j++)
63         {
64             double el = 0;
65             for (size_t k = 0; k < A->columns; k++)
66                 el += mat_el_at(A, i, k) * mat_el_at(B, k, j);
67             mat_set_el(res, i, j, el);
68         }
69     }
70 
71     return res;
72 }
.fi
.SS "\fBmatrix_t\fP * mat_scalar_multiply (\fBmatrix_t\fP * A, double scalar, int inplace)"

.PP
Multiplies the matrix by a given scalar\&. 
.PP
\fBParameters\fP
.RS 4
\fIA\fP The matrix to apply the scalar on\&. 
.br
\fIscalar\fP The scalar to be applied\&. 
.br
\fIinplace\fP A flag indicating whether the transform should be done in place or not\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to the transform matrix\&. 
.RE
.PP

.PP
Definition at line \fB110\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
111 {
112     matrix_t *res;
113     if (inplace)
114     {
115         res = A;
116     }
117     else
118     {
119         res = matrix_create(A->rows, A->columns, 0);
120     }
121 
122     if (res == NULL)
123         return NULL;
124     for (size_t i = 0; i < res->rows; i++)
125         for (size_t j = 0; j < res->columns; j++)
126             mat_set_el(res, i, j, mat_el_at(A, i, j) * scalar);
127     return res;
128 }
.fi
.SS "void mat_set_el (\fBmatrix_t\fP * mat, size_t i, size_t j, double value)"

.PP
Definition at line \fB12\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
13 {
14     size_t index = i * mat->columns + j;
15     mat->_elements[index] = value;
16 }
.fi
.SS "\fBmatrix_t\fP * mat_transform (\fBmatrix_t\fP * A, \fBmat_transform_t\fP transform, int inplace)"

.PP
Applies the transform to each of the matrix_elements\&. 
.PP
\fBParameters\fP
.RS 4
\fIA\fP The matrix to apply the transform on\&. 
.br
\fItransform\fP The transform to be applied\&. 
.br
\fIinplace\fP A boolean indicating whether the transform should be inplace\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to the transformed matrix\&. 
.RE
.PP

.PP
Definition at line \fB90\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
91 {
92     matrix_t *res;
93     if (inplace)
94     {
95         res = A;
96     }
97     else
98     {
99         res = matrix_create(A->rows, A->columns, 0);
100     }
101 
102     if (res == NULL)
103         return NULL;
104     for (size_t i = 0; i < res->rows; i++)
105         for (size_t j = 0; j < res->columns; j++)
106             mat_set_el(res, i, j, transform(mat_el_at(A, i, j)));
107     return res;
108 }
.fi
.SS "\fBmatrix_t\fP * mat_transpose (\fBmatrix_t\fP * A)"

.PP
Transposes the given matrix\&. 
.PP
\fBParameters\fP
.RS 4
\fIA\fP The matrix to be transposed\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The transposed matrix\&. 
.RE
.PP

.PP
Definition at line \fB130\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
131 {
132     matrix_t *res = matrix_create(A->columns, A->rows, 0);
133     if (res == NULL)
134         return NULL;
135 
136     for (size_t i = 0; i < res->rows; i++)
137         for (size_t j = 0; j < res->columns; j++)
138             mat_set_el(res, i, j, mat_el_at(A, j, i));
139     return res;
140 }
.fi
.SS "\fBmatrix_t\fP * matrix_create (size_t rows, size_t columns, int fill)"

.PP
Definition at line \fB18\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
19 {
20     matrix_t *res = (matrix_t *)malloc(sizeof(matrix_t));
21     if (res == NULL)
22         return NULL;
23     size_t count = rows * columns;
24     res->_elements = (double *)malloc(count * sizeof(double));
25     if (res->_elements == NULL)
26         return NULL;
27     if (fill)
28     {
29         for (size_t i = 0; i < count; i++)
30             res->_elements[i] = 0;
31     }
32 
33     res->rows = rows;
34     res->columns = columns;
35     return res;
36 }
.fi
.SS "matrix_free (\fBmatrix_t\fP * mat)"

.PP
frees the matrix 
.PP
\fBParameters\fP
.RS 4
\fImat\fP the matrix to free 
.RE
.PP

.PP
Definition at line \fB45\fP of file \fBmatrix\&.c\fP\&.
.PP
.nf
46 {
47     free(mat->_elements);
48     free(mat);
49 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for OCR-Lezcollitade from the source code\&.
