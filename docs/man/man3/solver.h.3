.TH "src/solver/solver.h" 3 "Tue Nov 22 2022" "OCR-Lezcollitade" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/solver/solver.h
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBcheckRow\fP (int *grid, int DIM)"
.br
.ti -1c
.RI "int \fBcheckCol\fP (int *grid, int DIM)"
.br
.ti -1c
.RI "int \fBcheckSquare\fP (int *grid, int DIM)"
.br
.ti -1c
.RI "int \fBallChecks\fP (int *grid, int DIM)"
.br
.ti -1c
.RI "int \fBwin\fP (int *grid, int DIM)"
.br
.ti -1c
.RI "int \fBsolve\fP (char *inputFile, int DIM)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int allChecks (int * grid, int DIM)"

.PP
Definition at line \fB87\fP of file \fBsolver\&.c\fP\&.
.PP
.nf
88 {
89     return checkSquare(grid, DIM) + checkCol(grid, DIM) + checkRow(grid, DIM)
90            == 3;
91 }
.fi
.SS "int checkCol (int * grid, int DIM)"

.PP
Definition at line \fB35\fP of file \fBsolver\&.c\fP\&.
.PP
.nf
36 {
37     for (int i = 0; i < DIM; i++)
38     {
39         int *histo = calloc(DIM + 1, sizeof(int));
40         for (int j = 0; j < DIM; j++)
41         {
42             histo[grid[j * DIM + i]]++;
43         }
44         for (int k = 1; k < DIM + 1; k++)
45         {
46             if (histo[k] > 1)
47             {
48                 free(histo);
49                 return 0;
50             }
51         }
52         free(histo);
53     }
54     return 1;
55 }
.fi
.SS "int checkRow (int * grid, int DIM)"

.PP
Definition at line \fB13\fP of file \fBsolver\&.c\fP\&.
.PP
.nf
14 {
15     for (int i = 0; i < DIM; i++)
16     {
17         int *histo = calloc(DIM + 1, sizeof(int));
18         for (int j = 0; j < DIM; j++)
19         {
20             histo[grid[i * DIM + j]]++;
21         }
22         for (int k = 1; k < DIM + 1; k++)
23         {
24             if (histo[k] > 1)
25             {
26                 free(histo);
27                 return 0;
28             }
29         }
30         free(histo);
31     }
32     return 1;
33 }
.fi
.SS "int checkSquare (int * grid, int DIM)"

.PP
Definition at line \fB57\fP of file \fBsolver\&.c\fP\&.
.PP
.nf
58 {
59     int sqDIM = sqrt(DIM);
60     for (int a = 0; a < DIM / sqDIM; a++)
61     {
62         for (int b = 0; b < DIM / sqDIM; b++)
63         {
64             int *histo = calloc(DIM + 1, sizeof(int));
65             for (int i = 0; i < DIM / sqDIM; i++)
66             {
67                 for (int j = 0; j < DIM / sqDIM; j++)
68                 {
69                     histo[grid[(a * DIM / sqDIM + i) * DIM
70                                + (b * DIM / sqDIM + j)]]++;
71                 }
72                 for (int k = 1; k < DIM + 1; k++)
73                 {
74                     if (histo[k] > 1)
75                     {
76                         free(histo);
77                         return 0;
78                     }
79                 }
80             }
81             free(histo);
82         }
83     }
84     return 1;
85 }
.fi
.SS "int solve (char * inputFile, int DIM)"

.PP
Definition at line \fB107\fP of file \fBsolver\&.c\fP\&.
.PP
.nf
108 {
109     if (DIM > 25
110         || (DIM != 1 && DIM != 4 && DIM != 9 && DIM != 16 && DIM != 25))
111     {
112         printf("Dimension shouls be <= 25 and its square root should be an "
113                "integer");
114         return 1;
115     }
116 
117     FILE *fpointer = fopen(inputFile, "r");
118     char line[2 * DIM];
119 
120     int *grid = calloc(sizeof(int), DIM * DIM);
121     int i = 0;
122 
123     while (fgets(line, 2 * DIM, fpointer))
124     {
125 
126         size_t k = 0, pk = 0;
127         while (line[pk] != '\n')
128         {
129 
130             if (line[pk] != ' ')
131             {
132                 if (line[pk] >= '1' && line[pk] <= '9')
133                     grid[i * DIM + k] = line[pk] - 48;
134                 else if (line[pk] >= 'A' && line[pk] <= 'Z')
135                     grid[i * DIM + k] = line[pk] - 55;
136                 else if (line[pk] != '\&.')
137                 {
138                     printf("Unknown charater %c\n", line[pk]);
139                     return 1;
140                 }
141                 k++;
142             }
143             pk++;
144         }
145         if (pk > 0)
146             i++;
147     }
148 
149     fclose(fpointer);
150 
151     // Debug
152 
153     /*
154     for(int i=0;i<DIM;i++){
155         for(int j=0;j<DIM;j++){
156         printf("%d\&.",grid[i][j]);
157         }
158         printf("\n");
159     }
160     //    printf("CheckRow : %d\n",checkRow(grid));
161     //    printf("CheckCol : %d\n",checkCol(grid));
162     //    printf("CheckSquare : %d\n",checkSquare(grid));
163 
164     */
165 
166     // Si mauvaise grille
167 
168     if (!checkCol(grid, DIM) || !checkRow(grid, DIM)
169         || !checkSquare(grid, DIM))
170     {
171         printf("Erreur dans grille d'entrée\n");
172         return 1;
173     }
174 
175     // On defini les case vides
176 
177     int nbEmpty = 0;
178     struct Cell empty[DIM * DIM];
179 
180     for (int i = 0; i < DIM; i++)
181     {
182         for (int j = 0; j < DIM; j++)
183         {
184             if (grid[i * DIM + j] == 0)
185             {
186                 struct Cell c;
187                 c\&.x = i;
188                 c\&.y = j;
189                 empty[nbEmpty] = c;
190                 nbEmpty++;
191             }
192         }
193     }
194 
195     // Debut de la boucle principale
196 
197     int index = 0;
198 
199     while (index < nbEmpty && index >= 0)
200     {
201         struct Cell curr = empty[index];
202         if (grid[curr\&.x * DIM + curr\&.y] < DIM)
203         {
204             grid[curr\&.x * DIM + curr\&.y]++;
205             if (allChecks(grid, DIM))
206                 index++;
207         }
208         else
209         {
210             grid[curr\&.x * DIM + curr\&.y] = 0;
211             index--;
212         }
213     }
214 
215     if (index < 0)
216     {
217         printf("Pas résolvable :(\n");
218         return 0;
219     }
220 
221     if (win(grid, DIM))
222     {
223         /*
224         printf("Voici la solution\n");
225         for(int i=0;i<DIM;i++){
226             for(int j=0;j<DIM;j++){
227                 printf("%d\&.",grid[i][j]);
228             }
229             printf("\n");
230         }*/
231 
232         // On ecrit dans un nouveau file
233         char outputExt[] = "\&.result";
234         strcat(inputFile, outputExt);
235         FILE *pfile = fopen(inputFile, "w");
236 
237         char ligne[2 * DIM];
238 
239         size_t mod = sqrt(DIM);
240 
241         for (int i = 0; i < DIM; i++)
242         {
243             if (i > 0 && i % mod == 0)
244                 fputs("\n", pfile);
245 
246             size_t pl = 0;
247             for (int j = 0; j < DIM; j++)
248             {
249                 if (j > 0 && j % mod == 0)
250                 {
251                     ligne[pl] = ' ';
252                     pl++;
253                 }
254 
255                 if (grid[i * DIM + j] < 10)
256                 {
257                     ligne[pl] = grid[i * DIM + j] + 48;
258                     pl++;
259                 }
260                 else
261                 {
262                     ligne[pl] = grid[i * DIM + j] + 55;
263                     pl++;
264                 }
265             }
266             ligne[pl] = '\0';
267             fputs(ligne, pfile);
268             fputs("\n", pfile);
269         }
270         fclose(pfile);
271     }
272 
273     free(grid);
274 
275     return 0;
276 }
.fi
.SS "int win (int * grid, int DIM)"

.PP
Definition at line \fB93\fP of file \fBsolver\&.c\fP\&.
.PP
.nf
94 {
95     for (int i = 0; i < DIM; i++)
96     {
97         for (int j = 0; j < DIM; j++)
98         {
99             if (grid[i * DIM + j] == 0)
100                 return 0;
101         }
102     }
103     return checkSquare(grid, DIM) + checkCol(grid, DIM) + checkRow(grid, DIM)
104            == 3;
105 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for OCR-Lezcollitade from the source code\&.
